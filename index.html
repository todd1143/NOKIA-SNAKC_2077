<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOKIA*SNAKC_2077</title>
    
    <!-- React and Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Leaderboard Data Management -->
    <script src="./leaderboard.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: system-ui, -apple-system, sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // === Tunables & labels ===
        const GAME_TITLE = "NOKIA*SNAKC_2077";
        const GRID = 24;
        const DEFAULT_TPS = 8;
        const MAX_TPS = 16;
        const WALLS = true;
        const API_BASE = "";

        function NeonCyberSnake() {
          // === Data Manager ===
          const leaderboardManager = useRef(window.LeaderboardManager);

          // === Canvas & main-loop refs ===
          const canvasRef = useRef(null);
          const rafRef = useRef(null);
          const accRef = useRef(0);
          const lastRef = useRef(null);
          const tpsRef = useRef(DEFAULT_TPS);

          // === UI/Game state ===
          const [running, setRunning] = useState(true);
          const [difficulty, setDifficulty] = useState("Chill");
          const [score, setScore] = useState(0);
          const [best, setBest] = useState(() => leaderboardManager.current.getBestScore());
          const [isGameOver, setIsGameOver] = useState(false);
          const [isAlive, setIsAlive] = useState(true);
          const [musicEnabled, setMusicEnabled] = useState(true);
          const [musicVolume, setMusicVolume] = useState(0.3);

          // === Leaderboard state ===
          const [name, setName] = useState(() => leaderboardManager.current.getPlayerName());
          const [submitting, setSubmitting] = useState(false);
          const [topScores, setTopScores] = useState([]);
          const [errorMsg, setErrorMsg] = useState("");
          const [playerStats, setPlayerStats] = useState(() => leaderboardManager.current.getPlayerStats());

          // === Gameplay model ===
          const snakeRef = useRef([]);
          const dirRef = useRef({ x: 1, y: 0 });
          const nextDirRef = useRef({ x: 1, y: 0 });
          const foodRef = useRef({ x: 10, y: 10 });
          const bonusRef = useRef(null);
          const growRef = useRef(0);
          const aliveRef = useRef(true);

          // === WebAudio for SFX and Music ===
          const audioCtxRef = useRef(null);
          const musicGainRef = useRef(null);
          const musicSourceRef = useRef(null);
          const musicBufferRef = useRef(null);
          const musicTimeoutRef = useRef(null);
          
          function ensureAudio() {
            if (!audioCtxRef.current) {
              const Ctx = window.AudioContext || window.webkitAudioContext;
              audioCtxRef.current = new Ctx();
              
              // Create master gain for music
              musicGainRef.current = audioCtxRef.current.createGain();
              musicGainRef.current.gain.value = musicVolume;
              musicGainRef.current.connect(audioCtxRef.current.destination);
            }
            return audioCtxRef.current;
          }
          
          // === Procedural Cyberpunk Background Music Generator ===
          function createCyberpunkMusic() {
            const ctx = ensureAudio();
            
            // Stop existing music and clear timeouts
            if (musicSourceRef.current) {
              musicSourceRef.current.stop();
              musicSourceRef.current = null;
            }
            if (musicTimeoutRef.current) {
              clearTimeout(musicTimeoutRef.current);
              musicTimeoutRef.current = null;
            }
            
            // Create a simple cyberpunk loop using oscillators
            const startMusic = () => {
              const now = ctx.currentTime;
              
              // Bass line pattern (repeating every 2 seconds)
              const playBassNote = (time, freq) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const filter = ctx.createBiquadFilter();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, time);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, time);
                filter.Q.setValueAtTime(10, time);
                
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.15, time + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(musicGainRef.current);
                
                osc.start(time);
                osc.stop(time + 0.5);
              };
              
              // Arpeggiator pattern
              const playArp = (time, freq) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const filter = ctx.createBiquadFilter();
                
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, time);
                
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(2000, time);
                filter.Q.setValueAtTime(5, time);
                
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.05, time + 0.005);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(musicGainRef.current);
                
                osc.start(time);
                osc.stop(time + 0.1);
              };
              
              // Hi-hat pattern
              const playHiHat = (time) => {
                const noise = ctx.createBufferSource();
                const noiseBuffer = ctx.createBuffer(1, 4410, ctx.sampleRate);
                const data = noiseBuffer.getChannelData(0);
                for (let i = 0; i < 4410; i++) {
                  data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = noiseBuffer;
                
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(8000, time);
                
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.03, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(musicGainRef.current);
                
                noise.start(time);
              };
              
              // Create a looping pattern
              const loop = () => {
                const loopTime = 4; // 4 second loop
                const now = ctx.currentTime;
                
                // Bass pattern (C-G-F-G in a cyberpunk style)
                const bassNotes = [
                  { time: 0, freq: 65.41 },    // C2
                  { time: 0.5, freq: 65.41 },
                  { time: 1, freq: 49 },        // G1
                  { time: 1.5, freq: 49 },
                  { time: 2, freq: 43.65 },     // F1
                  { time: 2.5, freq: 43.65 },
                  { time: 3, freq: 49 },        // G1
                  { time: 3.5, freq: 49 }
                ];
                
                // Arpeggio pattern
                const arpNotes = [
                  { time: 0, freq: 261.63 },    // C4
                  { time: 0.125, freq: 329.63 }, // E4
                  { time: 0.25, freq: 392 },     // G4
                  { time: 0.375, freq: 523.25 }, // C5
                  { time: 0.5, freq: 392 },      // G4
                  { time: 0.625, freq: 329.63 }, // E4
                  { time: 0.75, freq: 261.63 },  // C4
                  { time: 0.875, freq: 196 },    // G3
                ];
                
                // Schedule notes for the next loop
                for (let measure = 0; measure < 1; measure++) {
                  bassNotes.forEach(note => {
                    playBassNote(now + note.time, note.freq);
                  });
                  
                  // Play arpeggio 4 times per loop
                  for (let i = 0; i < 4; i++) {
                    arpNotes.forEach(note => {
                      playArp(now + i + note.time, note.freq * (1 + i * 0.1));
                    });
                  }
                  
                  // Hi-hat pattern (16th notes)
                  for (let i = 0; i < 16; i++) {
                    if (i % 2 === 0 || i === 7 || i === 15) {
                      playHiHat(now + i * 0.25);
                    }
                  }
                }
                
                // Schedule next loop
                musicTimeoutRef.current = setTimeout(loop, 3900); // Slightly less than 4 seconds to avoid gaps
              };
              
              // Start the loop
              if (musicEnabled) {
                loop();
              }
            };
            
            // Add some ambient pad
            const createAmbientPad = () => {
              const osc1 = ctx.createOscillator();
              const osc2 = ctx.createOscillator();
              const gain = ctx.createGain();
              const filter = ctx.createBiquadFilter();
              
              osc1.type = 'sine';
              osc1.frequency.setValueAtTime(65.41, ctx.currentTime); // C2
              osc2.type = 'sine';
              osc2.frequency.setValueAtTime(130.81, ctx.currentTime); // C3
              
              filter.type = 'lowpass';
              filter.frequency.setValueAtTime(500, ctx.currentTime);
              
              gain.gain.setValueAtTime(0.02, ctx.currentTime);
              
              osc1.connect(gain);
              osc2.connect(gain);
              gain.connect(filter);
              filter.connect(musicGainRef.current);
              
              osc1.start();
              osc2.start();
              
              // Store reference to stop later
              musicSourceRef.current = {
                stop: () => {
                  try {
                    osc1.stop();
                    osc2.stop();
                  } catch (e) {
                    // Ignore errors if already stopped
                  }
                  if (musicTimeoutRef.current) {
                    clearTimeout(musicTimeoutRef.current);
                    musicTimeoutRef.current = null;
                  }
                }
              };
            };
            
            if (musicEnabled) {
              startMusic();
              createAmbientPad();
            }
          }
          
          // Update music volume
          useEffect(() => {
            if (musicGainRef.current) {
              musicGainRef.current.gain.value = musicEnabled ? musicVolume : 0;
            }
          }, [musicVolume, musicEnabled]);
          
          // Start/stop music
          useEffect(() => {
            if (musicEnabled) {
              createCyberpunkMusic();
            } else if (musicSourceRef.current) {
              musicSourceRef.current.stop();
              musicSourceRef.current = null;
            }
            
            return () => {
              if (musicSourceRef.current) {
                musicSourceRef.current.stop();
                musicSourceRef.current = null;
              }
              if (musicTimeoutRef.current) {
                clearTimeout(musicTimeoutRef.current);
                musicTimeoutRef.current = null;
              }
            };
          }, [musicEnabled]);
          
          function beep({ freq = 440, dur = 0.08, type = "sine", gain = 0.06 }) {
            try {
              const ctx = ensureAudio();
              const t0 = ctx.currentTime;
              const osc = ctx.createOscillator();
              const g = ctx.createGain();
              osc.type = type;
              osc.frequency.setValueAtTime(freq, t0);
              g.gain.setValueAtTime(gain, t0);
              g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
              osc.connect(g).connect(ctx.destination);
              osc.start(t0);
              osc.stop(t0 + dur + 0.02);
            } catch (e) {
              // Silent fail if audio doesn't work
            }
          }
          
          const sfx = {
            move: () => beep({ freq: 260, dur: 0.03, type: "square", gain: 0.03 }),
            eat: () => beep({ freq: 720, dur: 0.09, type: "triangle", gain: 0.06 }),
            bonus: () => {
              beep({ freq: 600, dur: 0.06, type: "sawtooth", gain: 0.08 });
              setTimeout(() => beep({ freq: 900, dur: 0.08, type: "sawtooth", gain: 0.08 }), 60);
            },
            crash: () => {
              beep({ freq: 120, dur: 0.25, type: "square", gain: 0.08 });
              setTimeout(() => beep({ freq: 80, dur: 0.22, type: "square", gain: 0.07 }), 80);
            },
            pause: () => beep({ freq: 420, dur: 0.04, type: "sine", gain: 0.04 }),
            resume: () => beep({ freq: 540, dur: 0.06, type: "sine", gain: 0.05 }),
          };

          // === Leaderboard functions ===
          const loadLeaderboard = () => {
            const scores = leaderboardManager.current.getLeaderboard(10);
            setTopScores(scores);
          };

          const submitScore = () => {
            if (!name.trim() || score === 0) {
              setErrorMsg("Valid name and score required");
              return;
            }

            setSubmitting(true);
            setErrorMsg("");

            try {
              // Submit score to leaderboard
              const success = leaderboardManager.current.submitScore({
                name: name.trim(),
                score: score,
                difficulty: difficulty
              });

              if (!success) {
                throw new Error("Failed to submit score");
              }

              // Update player statistics
              const newStats = leaderboardManager.current.updatePlayerStats(score);
              setPlayerStats(newStats);
              
              // Reload leaderboard
              loadLeaderboard();
              
              setErrorMsg("Score submitted successfully!");
              setTimeout(() => setErrorMsg(""), 3000);
              
            } catch (error) {
              setErrorMsg("Submission failed, please try again");
            } finally {
              setSubmitting(false);
            }
          };

          // === Initial setup & keyboard input ===
          useEffect(() => { 
            resetGame(); 
            loadLeaderboard();
          }, []);
          
          useEffect(() => {
            tpsRef.current = difficulty === "Chill" ? 8 : (difficulty === "Swift" ? 12 : 16);
          }, [difficulty]);
          
          useEffect(() => {
            function onKey(e) {
              if (e.key === " " || e.code === "Space") {
                e.preventDefault();
                setRunning(r => {
                  if (r) sfx.pause();
                  else sfx.resume();
                  return !r;
                });
                return;
              }
              if (e.key === "r" || e.key === "R") {
                resetGame();
                setRunning(true);
                return;
              }
              if (e.key === "m" || e.key === "M") {
                setMusicEnabled(m => !m);
                return;
              }
              const d = keyToDir(e.key);
              if (!d) return;
              e.preventDefault(); // 阻止方向鍵滾動頁面
              const curr = dirRef.current;
              if (curr.x + d.x === 0 && curr.y + d.y === 0) return;
              nextDirRef.current = d;
              sfx.move();
            }
            window.addEventListener('keydown', onKey);
            return () => window.removeEventListener('keydown', onKey);
          }, []);

          // === Responsive canvas sizing ===
          const [canvasSize, cellSize] = useCanvasSize(GRID);

          // === Main loop ===
          useEffect(() => {
            const ctx = canvasRef.current?.getContext('2d');
            if (!ctx) return;

            function loop(ts) {
              if (!lastRef.current) lastRef.current = ts;
              const dt = (ts - lastRef.current) / 1000;
              lastRef.current = ts;

              if (running && aliveRef.current) {
                accRef.current += dt;
                const stepTime = 1 / tpsRef.current;
                while (accRef.current >= stepTime) {
                  step();
                  accRef.current -= stepTime;
                }
              }

              draw(ctx, canvasSize, cellSize);
              rafRef.current = requestAnimationFrame(loop);
            }

            rafRef.current = requestAnimationFrame(loop);
            return () => {
              if (rafRef.current) cancelAnimationFrame(rafRef.current);
              rafRef.current = null;
              lastRef.current = null;
              accRef.current = 0;
            };
          }, [canvasSize, cellSize, running]);

          // === Helpers ===
          function keyToDir(key) {
            if (key === 'ArrowUp' || key === 'w' || key === 'W') return { x: 0, y: -1 };
            if (key === 'ArrowDown' || key === 's' || key === 'S') return { x: 0, y: 1 };
            if (key === 'ArrowLeft' || key === 'a' || key === 'A') return { x: -1, y: 0 };
            if (key === 'ArrowRight' || key === 'd' || key === 'D') return { x: 1, y: 0 };
            return null;
          }

          function randCell(ex) {
            let x = 0, y = 0, g = 0;
            do {
              x = Math.floor(Math.random() * GRID);
              y = Math.floor(Math.random() * GRID);
              g++;
              if (g > 2000) break;
            } while (ex.has(`${x},${y}`));
            return { x, y };
          }

          function maybeSpawnBonus(ex) {
            if (bonusRef.current) return;
            if (Math.random() < 0.06) bonusRef.current = randCell(ex);
          }

          function resetGame(seedDir = { x: 1, y: 0 }) {
            const start = [{ x: 6, y: 12 }, { x: 5, y: 12 }, { x: 4, y: 12 }];
            snakeRef.current = start;
            dirRef.current = seedDir;
            nextDirRef.current = seedDir;
            aliveRef.current = true;
            setIsGameOver(false);
            setIsAlive(true);
            growRef.current = 0;
            setScore(0);
            const ex = new Set(start.map(s => `${s.x},${s.y}`));
            foodRef.current = randCell(ex);
            bonusRef.current = null;
            lastRef.current = null;
            accRef.current = 0;
          }

          function step() {
            const snake = snakeRef.current;
            const dir = nextDirRef.current;
            dirRef.current = dir;

            const head = snake[0];
            let nx = head.x + dir.x, ny = head.y + dir.y;

            if (!WALLS) {
              nx = (nx + GRID) % GRID;
              ny = (ny + GRID) % GRID;
            }

            if (WALLS && (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID)) {
              aliveRef.current = false;
              setIsGameOver(true);
              setIsAlive(false);
              updateBest();
              sfx.crash();
              return;
            }

            const newHead = { x: nx, y: ny };
            const bodyToCheck = (growRef.current > 0) ? snake : snake.slice(0, -1);
            if (bodyToCheck.some(s => s.x === nx && s.y === ny)) {
              aliveRef.current = false;
              setIsGameOver(true);
              setIsAlive(false);
              updateBest();
              sfx.crash();
              return;
            }

            snake.unshift(newHead);

            if (nx === foodRef.current.x && ny === foodRef.current.y) {
              setScore(s => s + 10);
              growRef.current += 1;
              const ex = new Set(snake.map(s => `${s.x},${s.y}`));
              foodRef.current = randCell(ex);
              maybeSpawnBonus(ex);
              sfx.eat();
            }

            if (bonusRef.current && nx === bonusRef.current.x && ny === bonusRef.current.y) {
              setScore(s => s + 30);
              growRef.current += 2;
              bonusRef.current = null;
              tpsRef.current = Math.min(MAX_TPS, tpsRef.current + 2);
              sfx.bonus();
              setTimeout(() => {
                tpsRef.current = difficulty === "Chill" ? 8 : (difficulty === "Swift" ? 12 : 16);
              }, 1200);
            }

            if (growRef.current > 0) {
              growRef.current -= 1;
            } else {
              snake.pop();
            }
          }

          function updateBest() {
            setBest(b => {
              const next = leaderboardManager.current.updateBestScore(score);
              return next;
            });
          }

          function draw(ctx, size, cell) {
            // Backdrop
            const g = ctx.createLinearGradient(0, 0, size, size);
            g.addColorStop(0, "#040409");
            g.addColorStop(1, "#0a0113");
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, size, size);

            // Grid
            ctx.strokeStyle = "rgba(0,255,255,0.06)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i <= GRID; i++) {
              const p = i * cell + 0.5;
              ctx.moveTo(0, p);
              ctx.lineTo(size, p);
              ctx.moveTo(p, 0);
              ctx.lineTo(p, size);
            }
            ctx.stroke();

            // Food & bonus
            const f = foodRef.current;
            neonRect(ctx, f.x * cell, f.y * cell, cell, cell, "#00FFF0", "#00A3FF");
            if (bonusRef.current) {
              const b = bonusRef.current;
              neonCircle(ctx, b.x * cell + cell / 2, b.y * cell + cell / 2, cell * 0.38, "#FF00B8");
            }

            // Snake
            const snake = snakeRef.current;
            for (let i = snake.length - 1; i >= 0; i--) {
              const s = snake[i];
              const t = i === 0 ? 1 : i / snake.length;
              const hue = 180 + t * 140;
              const color = `hsl(${hue},100%,55%)`;
              neonRect(ctx, s.x * cell, s.y * cell, cell, cell, color);
              if (i === 0) {
                ctx.fillStyle = "rgba(0,0,0,0.35)";
                ctx.fillRect(s.x * cell + cell * 0.2, s.y * cell + cell * 0.25, cell * 0.6, cell * 0.12);
              }
            }

            // Game over overlay
            if (!aliveRef.current) {
              ctx.fillStyle = "rgba(10,0,20,0.65)";
              ctx.fillRect(0, 0, size, size);
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              
              // Responsive font sizing with limits
              const baseFontSize = Math.max(16, Math.min(size * 0.06, 32));
              const smallFontSize = Math.max(14, Math.min(size * 0.04, 24));
              
              // Main failure text
              ctx.font = `${baseFontSize}px Orbitron, Audiowide, Menlo, monospace`;
              ctx.fillStyle = "#fff";
              ctx.shadowColor = "#ff00b8";
              ctx.shadowBlur = 18;
              ctx.fillText("SYSTEM FAILURE", size / 2, size / 2 - 24);
              
              // Error code text (smaller)
              ctx.font = `${smallFontSize}px Orbitron, Audiowide, Menlo, monospace`;
              ctx.shadowColor = "#ff0066";
              ctx.shadowBlur = 12;
              ctx.fillText("0xDEAD_SNAKE", size / 2, size / 2 + 2);
              
              // Instruction text
              ctx.shadowColor = "#00f0ff";
              ctx.shadowBlur = 15;
              ctx.fillText("Press R to Reboot", size / 2, size / 2 + 32);
              ctx.shadowBlur = 0;
            }
          }

          function neonRect(ctx, x, y, w, h, color, stroke) {
            const r = Math.min(w, h) * 0.25;
            const grd = ctx.createLinearGradient(x, y, x + w, y + h);
            grd.addColorStop(0, color);
            grd.addColorStop(1, "#ffffff");
            ctx.fillStyle = grd;
            ctx.shadowColor = color;
            ctx.shadowBlur = 14;
            roundRect(ctx, x + 2, y + 2, w - 4, h - 4, r);
            ctx.fill();
            if (stroke) {
              ctx.shadowBlur = 24;
              ctx.strokeStyle = stroke;
              ctx.lineWidth = 1.8;
              roundRect(ctx, x + 2, y + 2, w - 4, h - 4, r);
              ctx.stroke();
            }
            ctx.shadowBlur = 0;
          }

          function neonCircle(ctx, x, y, r, color) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            const g = ctx.createRadialGradient(x, y, r * 0.2, x, y, r);
            g.addColorStop(0, "#fff");
            g.addColorStop(1, color);
            ctx.fillStyle = g;
            ctx.shadowColor = color;
            ctx.shadowBlur = 18;
            ctx.fill();
            ctx.shadowBlur = 0;
          }

          function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
          }

          // On-screen D-Pad
          function onDirClick(d) {
            const curr = dirRef.current;
            if (curr.x + d.x === 0 && curr.y + d.y === 0) return;
            nextDirRef.current = d;
            sfx.move();
          }

          function onRestart() {
            resetGame();
            setRunning(true);
          }

          // Styles
          const Styles = (
            <>
              <link rel="preconnect" href="https://fonts.googleapis.com" />
              <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
              <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@400..900&family=Share+Tech+Mono&display=swap" rel="stylesheet" />
              <style>{`
                :root{
                  --title-font:'Audiowide','Orbitron',system-ui,ui-sans-serif;
                  --ui-font:'Share Tech Mono', ui-monospace, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace;
                }
                *{ box-sizing:border-box }
                .wrap{ min-height:100vh; background:#000; color:#d4d4d8; font-family:var(--ui-font); }
                .container{ max-width:950px; margin:0 auto; padding:20px 16px; }
                @media (min-width: 640px){ .container{ padding:24px 20px; } }
                @media (min-width: 1024px){ .container{ padding:32px 24px; } }
                .header{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding-bottom:16px; flex-wrap:wrap; }
                @media (max-width: 640px){ .header{ flex-direction:column; align-items:flex-start; gap:8px; } }
                .title{ font-family:var(--title-font); letter-spacing:.24em; text-transform:uppercase; font-size:clamp(24px,4vw,48px); font-weight:900; }
                .neon-flow{
                  background: linear-gradient(90deg, 
                    #4a9999 0%, #4a9999 15%, 
                    #00fff0 20%, #56b6ff 25%, #b400ff 30%, #ff00b8 35%, #00fff0 40%,
                    rgba(0,255,240,0.6) 42%, rgba(0,255,240,0.3) 45%, rgba(74,153,153,0.8) 50%,
                    #4a9999 55%, #4a9999 100%
                  );
                  background-size: 300% 100%;
                  -webkit-background-clip: text;
                  background-clip: text;
                  color: transparent;
                  animation: snakeFlow 3.5s linear infinite;
                  position: relative;
                }
                .neon-flow::before{
                  content: attr(data-text);
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  background: linear-gradient(90deg, 
                    transparent 0%, transparent 15%,
                    rgba(0,255,240,0.4) 18%, rgba(0,255,240,0.8) 20%, 
                    rgba(86,182,255,0.9) 25%, rgba(180,0,255,0.9) 30%, 
                    rgba(255,0,184,0.9) 35%, rgba(0,255,240,0.8) 40%,
                    rgba(0,255,240,0.4) 42%, rgba(0,255,240,0.2) 45%, 
                    transparent 50%, transparent 100%
                  );
                  background-size: 300% 100%;
                  -webkit-background-clip: text;
                  background-clip: text;
                  color: transparent;
                  animation: snakeFlow 3.5s linear infinite;
                  filter: blur(0.8px);
                }
                .neon-flow::after{
                  content: attr(data-text);
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  color: rgba(0,255,240,0.15);
                  filter: blur(2px);
                  z-index: -1;
                }
                @keyframes snakeFlow{ 
                  0%{ background-position: -100% 0; }
                  100%{ background-position: 200% 0; }
                }
                .kbd{ border:1px solid rgba(0,255,255,.3); background:rgba(0,255,255,.08); color:#a7f3f0; border-radius:8px; padding:4px 8px; font-size:12px }
                .grid{ display:grid; grid-template-columns:1fr; gap:20px; }
                @media (min-width:768px){ .grid{ grid-template-columns:1fr 320px } }
                .bar{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:16px; }
                .panel{ border:1px solid rgba(255,255,255,.15); border-radius:16px; padding:12px; background:rgba(255,255,255,.03); }
                .score{ text-align:center; }
                .score h5{ font-size:11px; letter-spacing:.24em; text-transform:uppercase; color:rgba(34,211,238,.8); margin:0 0 6px }
                .score .val{ font-size:22px; filter:drop-shadow(0 0 8px rgba(34,211,238,.9)); }
                .best h5{ color:rgba(244,114,182,.8) }
                .best .val{ filter:drop-shadow(0 0 8px rgba(244,114,182,.9)); }
                .controls{ display:flex; gap:8px; align-items:stretch; width:100%; }
                select,button,input{ font-family:var(--ui-font); }
                select, input{ background:#0a0a0a; border:1px solid #3f3f46; color:#e4e4e7; border-radius:12px; padding:8px 10px; outline:none }
                button{ background:#0a0a0a; color:#e4e4e7; border:1px solid #3f3f46; border-radius:12px; padding:8px 12px; cursor:pointer }
                button:hover{ border-color:rgba(0,255,255,.5) }
                .frame{ border-radius:24px; padding:2px; background:linear-gradient(120deg, rgba(0,255,240,.5), rgba(180,0,255,.5)); display:inline-block }
                .frame-inner{ border-radius:22px; background:#0a0a0a; padding:10px; box-shadow:inset 0 0 40px rgba(255,255,255,.06) }
                .canvas-wrap{ border-radius:18px; background:linear-gradient(135deg,#0a0a0a,#111); padding:8px; }
                .dpad{ display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-top:12px }
                .note{ color:#a1a1aa; font-size:12px; text-align:center; margin-top:4px }
                .game-controls{ border:1px solid rgba(0,255,240,.2); background:rgba(0,255,240,.03); border-radius:16px; padding:12px; margin-top:8px; }
                .game-controls h3{ font-size:12px; letter-spacing:.2em; text-transform:uppercase; color:#00fff0; margin:0 0 10px; font-family:var(--title-font) }
                .aside{ position:sticky; top:16px; align-self:start; border:1px solid rgba(255,255,255,.1); background:rgba(12,12,12,.85); border-radius:16px; padding:16px; backdrop-filter:blur(8px); }
                @media (max-width: 767px){ .aside{ position:static; margin-top:16px; } }
                .aside h3{ font-size:12px; letter-spacing:.2em; text-transform:uppercase; color:#e5e7eb; margin:0 0 8px; font-family:var(--title-font) }

                .volume-slider{ 
                  width:100%; 
                  accent-color:#00fff0; 
                  height:6px; 
                  border-radius:3px; 
                  background:rgba(255,255,255,0.1); 
                  outline:none; 
                  cursor:pointer;
                }
                .volume-slider::-webkit-slider-thumb{ 
                  appearance:none; 
                  width:16px; 
                  height:16px; 
                  border-radius:50%; 
                  background:linear-gradient(135deg, #00fff0, #b400ff); 
                  cursor:pointer; 
                  border:2px solid rgba(255,255,255,0.3);
                  box-shadow:0 0 8px rgba(0,255,240,0.5);
                }
                .volume-slider::-moz-range-thumb{ 
                  width:16px; 
                  height:16px; 
                  border-radius:50%; 
                  background:linear-gradient(135deg, #00fff0, #b400ff); 
                  cursor:pointer; 
                  border:2px solid rgba(255,255,255,0.3);
                  box-shadow:0 0 8px rgba(0,255,240,0.5);
                }
                .volume-slider:disabled{ 
                  opacity:0.4; 
                  cursor:not-allowed;
                }
                .volume-slider:disabled::-webkit-slider-thumb{ 
                  background:#666; 
                  box-shadow:none;
                  cursor:not-allowed;
                }
                .volume-slider:disabled::-moz-range-thumb{ 
                  background:#666; 
                  box-shadow:none;
                  cursor:not-allowed;
                }
                @media (max-width: 639px){ .dpad{ display:grid } }
                @media (min-width: 640px){ .dpad{ display:none } }
                .main-content{ display:flex; flex-direction:column; gap:16px; }
                .game-section{ flex:1; }
                .info-section{ margin-top:8px; }
              `}</style>
            </>
          );

          // Render
          return (
            <div className="wrap">
              {Styles}
              <div className="container">
                <div className="header">
                  <div className="title">
                    <span className="neon-flow" data-text={GAME_TITLE}>{GAME_TITLE}</span>
                  </div>
                  <div style={{ display: 'flex', gap: 8, alignItems: 'center', fontSize: 12 }}>
                    <span className="kbd">WASD</span><span style={{ color: '#71717a' }}>/</span>
                    <span className="kbd" style={{ borderColor: 'rgba(255,0,184,.3)', background: 'rgba(255,0,184,.08)', color: '#f5d0fe' }}>Arrows</span>
                    <span style={{ color: '#71717a' }}>•</span>
                    <span className="kbd" style={{ borderColor: 'rgba(244,114,182,.3)', background: 'rgba(244,114,182,.08)', color: '#fbcfe8' }}>M</span>
                    <span style={{ color: '#a1a1aa' }}>Music</span>
                  </div>
                </div>

                <div className="grid">
                  <div className="main-content">
                    <div className="bar">
                      <div className="panel score">
                        <h5>Score</h5>
                        <div className="val">{score}</div>
                      </div>
                      <div className="panel score best">
                        <h5>Best</h5>
                        <div className="val">{best}</div>
                      </div>

                    </div>

                    <div className="game-section">
                      <div className="frame">
                        <div className="frame-inner">
                          <div className="canvas-wrap">
                            <canvas ref={canvasRef} width={canvasSize} height={canvasSize} style={{ display: 'block', borderRadius: 16, border: '1px solid rgba(34,211,238,.25)', boxShadow: '0 0 40px rgba(0,255,255,.2)' }} />
                          </div>
                        </div>
                      </div>
                    </div>

                    <div className="dpad">
                      <div />
                      <button onClick={() => onDirClick({ x: 0, y: -1 })}>▲</button>
                      <div />
                      <button onClick={() => onDirClick({ x: -1, y: 0 })}>◀</button>
                      <button onClick={() => setRunning(r => { if (r) sfx.pause(); else sfx.resume(); return !r; })}>■</button>
                      <button onClick={() => onDirClick({ x: 1, y: 0 })}>▶</button>
                      <div />
                      <button onClick={() => onDirClick({ x: 0, y: 1 })}>▼</button>
                      <div />
                    </div>

                    <div className="info-section">
                      <div className="note">Tip: eat the <span style={{ color: '#67e8f9' }}>cyan</span> cube. The <span style={{ color: '#f472b6' }}>magenta</span> orb gives bonus & speed. Press <strong>M</strong> to toggle music.</div>
                    </div>
                  </div>

                  <aside className="aside">
                    <h3>Leaderboard</h3>
                    <div style={{ display: 'flex', gap: 8 }}>
                      <input 
                        value={name} 
                        onChange={e => {
                          const newName = e.target.value;
                          setName(newName);
                          if (newName.trim()) {
                            leaderboardManager.current.savePlayerName(newName.trim());
                          }
                        }} 
                        maxLength={16} 
                        placeholder="Your name" 
                      />
                      <button 
                        disabled={!isGameOver || submitting || score === 0} 
                        onClick={submitScore}
                        style={{ 
                          background: (!isGameOver || submitting || score === 0) ? '#0a0a0a' : '#1a0a2a',
                          borderColor: (!isGameOver || submitting || score === 0) ? '#3f3f46' : '#00fff0',
                          opacity: (!isGameOver || submitting || score === 0) ? 0.5 : 1
                        }}
                      >
                        {submitting ? 'Submitting...' : 'Submit'}
                      </button>
                    </div>
                    {errorMsg && <div style={{ color: errorMsg.includes('successfully') ? '#10b981' : '#f87171', marginTop: 6, fontSize: 12 }}>{errorMsg}</div>}
                    
                    <div style={{ marginTop: 12 }}>
                      {topScores.length > 0 ? (
                        <div>
                          <div style={{ fontSize: 11, color: '#a1a1aa', marginBottom: 8 }}>🏆 Top Scores</div>
                          <div style={{ maxHeight: '120px', overflowY: 'auto' }}>
                            {topScores.slice(0, 5).map((entry, index) => (
                              <div key={`${entry.name}-${entry.timestamp}`} style={{ 
                                display: 'flex', 
                                justifyContent: 'space-between', 
                                alignItems: 'center',
                                padding: '4px 8px', 
                                marginBottom: '2px',
                                background: entry.name === name ? 'rgba(0,255,240,0.1)' : 'rgba(255,255,255,0.02)',
                                borderRadius: '6px',
                                fontSize: '11px'
                              }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                                  <span style={{ color: index === 0 ? '#ffd700' : index === 1 ? '#c0c0c0' : index === 2 ? '#cd7f32' : '#a1a1aa', minWidth: '16px' }}>
                                    #{index + 1}
                                  </span>
                                  <span style={{ color: entry.name === name ? '#00fff0' : '#e4e4e7' }}>{entry.name}</span>
                                </div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                                  <span style={{ color: '#00fff0', fontWeight: 'bold' }}>{entry.score}</span>
                                  <span style={{ color: '#a1a1aa', fontSize: '9px' }}>{entry.difficulty}</span>
                                </div>
                              </div>
                            ))}
                          </div>
                        </div>
                      ) : (
                        <div style={{ fontSize: 11, color: '#a1a1aa' }}>No scores yet. Be the first to set a record!</div>
                      )}
                      
                      <div style={{ border: '1px solid rgba(255,255,255,0.1)', borderRadius: '12px', padding: '12px', background: 'rgba(255,255,255,0.02)', marginTop: '12px' }}>
                        <h4 style={{ fontSize: '11px', letterSpacing: '.2em', textTransform: 'uppercase', color: '#a1a1aa', margin: '0 0 8px', fontFamily: 'var(--title-font)' }}>Player Stats</h4>
                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', fontSize: '12px' }}>
                          <div>
                            <div style={{ color: '#71717a', fontSize: '10px' }}>Current Score</div>
                            <div style={{ color: '#00fff0', fontWeight: 'bold' }}>{score}</div>
                          </div>
                          <div>
                            <div style={{ color: '#71717a', fontSize: '10px' }}>Personal Best</div>
                            <div style={{ color: '#f472b6', fontWeight: 'bold' }}>{best}</div>
                          </div>
                          <div>
                            <div style={{ color: '#71717a', fontSize: '10px' }}>Games Played</div>
                            <div style={{ color: '#a78bfa' }}>{playerStats.gamesPlayed}</div>
                          </div>
                          <div>
                            <div style={{ color: '#71717a', fontSize: '10px' }}>Avg Score</div>
                            <div style={{ color: '#10b981' }}>{playerStats.avgScore}</div>
                          </div>
                        </div>
                        <div style={{ marginTop: '8px', paddingTop: '8px', borderTop: '1px solid rgba(255,255,255,0.1)' }}>
                          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <div style={{ color: '#71717a', fontSize: '10px' }}>Status</div>
                            <div style={{ color: isAlive ? '#10b981' : '#ef4444', fontSize: '11px' }}>
                              {isAlive ? 'Playing' : 'Game Over'}
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      <div style={{ marginTop: '16px', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '12px', padding: '12px', background: 'rgba(255,255,255,0.02)' }}>
                        <h4 style={{ fontSize: '11px', letterSpacing: '.2em', textTransform: 'uppercase', color: '#a1a1aa', margin: '0 0 8px', fontFamily: 'var(--title-font)' }}>Controls</h4>
                        <div style={{ fontSize: '11px', lineHeight: '1.4', color: '#71717a' }}>
                          <div style={{ marginBottom: '4px' }}><span style={{ color: '#00fff0' }}>WASD/Arrows:</span> Move</div>
                          <div style={{ marginBottom: '4px' }}><span style={{ color: '#00fff0' }}>Space:</span> Pause/Resume</div>
                          <div style={{ marginBottom: '4px' }}><span style={{ color: '#00fff0' }}>R:</span> Restart</div>
                          <div><span style={{ color: '#00fff0' }}>M:</span> Toggle Music</div>
                        </div>
                      </div>
                    </div>
                  </aside>

                  <div className="game-controls">
                    <h3>Game Controls</h3>
                    <div className="controls">
                      <select value={difficulty} onChange={e => setDifficulty(e.target.value)}>
                        <option>Chill</option><option>Swift</option><option>Hyper</option>
                      </select>
                      <button onClick={() => setRunning(r => { if (r) sfx.pause(); else sfx.resume(); return !r; })}>{running ? 'Pause' : 'Resume'}</button>
                      <button onClick={onRestart}>Restart</button>
                      
                      <div className="music-inline" style={{ display: 'flex', alignItems: 'center', gap: 6, marginLeft: 8, flex: 1 }}>
                        <button 
                          onClick={() => setMusicEnabled(m => !m)} 
                          style={{ 
                            background: 'transparent',
                            border: 'none',
                            fontSize: '16px',
                            cursor: 'pointer',
                            padding: '4px',
                            borderRadius: '6px',
                            transition: 'all 0.2s ease',
                            filter: musicEnabled ? 'none' : 'grayscale(1) opacity(0.5)',
                            flexShrink: 0
                          }}
                          title={musicEnabled ? 'Music ON' : 'Music OFF'}
                        >
                          🎵
                        </button>
                        <input 
                          type="range" 
                          min="0" 
                          max="100" 
                          value={musicVolume * 100} 
                          onChange={e => setMusicVolume(e.target.value / 100)}
                          className="volume-slider"
                          style={{ flex: 1, minWidth: '60px' }}
                          disabled={!musicEnabled}
                        />
                        <span style={{ fontSize: 9, color: '#a1a1aa', minWidth: '28px', textAlign: 'right', flexShrink: 0 }}>
                          {Math.round(musicVolume * 100)}%
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        }

        // Responsive canvas sizing hook
        function useCanvasSize(GRID) {
          const compute = () => {
            const vw = Math.max(320, Math.min(1024, window.innerWidth));
            const max = vw - 32;
            const target = Math.min(560, max);
            const cell = Math.max(12, Math.floor(target / GRID));
            const size = cell * GRID;
            return [size, cell];
          };

          const [state, setState] = useState(compute());
          useEffect(() => {
            const onResize = () => setState(compute());
            window.addEventListener('resize', onResize);
            return () => window.removeEventListener('resize', onResize);
          }, []);
          return state;
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(NeonCyberSnake));
    </script>
</body>
</html>